Åternity 블록 체인

신뢰할 수없고 분산 된 순전히 기능적인 오라클 머신 

2017 년 2 월 6 일

v0.1

Zackary Hess zack@aeternity.com

야니 슬라브 말라 호스 yani@aeternity.com

잭 페터슨 jack@aeternity.com

초록 - 2014 년에 에리트레늄 도입 이후 분산 된 트러스트리스 애플리케이션에 큰 관심을 보였습니다. (현명한 계약). 결과적으로, 많은 사람들이 실제 세계 데이터가 블록 체인 상단에있는 애플리케이션. 우리 응용 프로그램의 상태 및 코드를 체인에 저장하는 것이 여러 가지 이유로 잘못되었습니다. 우리는 확장 성이 뛰어난 블록 체인 아키텍처를 제공합니다. 오라클을 확인하는 데에도 사용되는 합의 메커니즘. 오라클은 레이어링을 피하기 때문에 매우 효율적입니다. 하나의 합의 메커니즘이 다른 것의 위에있다. 상태 채널 개인 정보 보호 및 확장 성을 높이기 위해 통합되었습니다. 토큰 순전히 기능적인 스마트를 사용하여 채널을 전송할 수 있습니다. 오라클의 답변에 액세스 할 수있는 계약. 계약을 저장하지 않음으로써 코드 또는 상태 체인을 통해 스마트 계약을 체결 할 수 있습니다. 실질적인 손실없이 분석하기 쉽고 처리가 빠릅니다. 사실상의 기능입니다. 합성 자산 및 예측 시장과 같은 애플리케이션 시장은 전 세계적 규모에서 효율적으로 구현 될 수 있습니다. 수개 부품은 Erlang에서 개념 증명을 구현했습니다. 개발 - 지갑, 이름 지정 등의 도구 및 응용 프로그램 필수 기능 신분 확인 시스템도 제공 될 것입니다. 

C ONTENTS 

나는 소개 1 

IA 이전 작업. . . . . . . . .. . . . . . 2 

II Åternity 블록 체인. . . . . . . . .. 2 

II-A 토큰, 계정 및 블록 . . .. . . . . . . 2 

II-A.1 액세스 토큰, 이온 . . .. . . . . . 2 

II-A.2 계정. . . . . . . . .. . . . . . 2 

II-A.3 이름 시스템 . . . . . . . . . .. . 3 

II-A.4 블록 내용 . . . . . .. . . . . . 3 

II-B 주 채널 . . . . . . . .. . . . .  . 3 

II-B.1 스마트 계약 . . . . .. . . . . . 3 

II-B.2 예 . . . . . . . . .. . . . . . 4 

II-C 일치 메커니즘. . . . . .. . . . . . 5 

II-C.1 오라클 . . . . . . . . . . . . . . 5 

II-D 거버넌스. . . . . . . . . . . . . . . 5 

II-E 확장 성 . . . . . . .  . . . . . . . 6 

II-E.1 샤딩 나무 . . . . . . . . . . . . 6 

II-E.2 빛 클라이언트 . . . . . . . . . .  6 

II-E.3 상태 채널 및 paral- lelism . . . . 6 

II-E.4 초당 거래 주어진 메모리 요구 사항 (6) 

III 응용 프로그램 6 

III-A Blockchain 필수 . . . . . . . . . 6 

III-A.1 ID를 . . . . . . . . . . 6 

III-A.2 지갑 . . . . . . . . . . . 6 

III-A.3 존재의 증명 . . . . . 6 

III-B 주 채널 응용 프로그램 . . . . . . . 7 

III-B.1 유료 API . . . . . . . . . . 7 

III-B.2 보험 크라우드 펀딩 . . . 7 

III-B.3 크로스 체인 원자 스왑 . 7 

III-B.4 안정적인 가치 자산 및 포트폴리오 복제 . . . . 7 

III-B.5 이벤트 계약 . . . . . . 7 

III-B.6 예측 시장 . . . . . 7 

III-B.7 일괄 거래를 통한 시장 하나의 가격으로 . . . . . . 7 

IV 이행 8 IV-A 가상 머신 및 계약 언어 8 

Ⅳ-B 웹 통합을 통해 채택 . . . . . 8 

IV-C 오픈 소스 모듈. . . . . . . . . 8 

IV-D 유용성 및 UX 디자인 . . . . . . . 8 

V 토론 8 버지니아 주 제한 사항 및 장단점 . . . . . . . 9 

VA.1 온 상태 체인 . . . . . . . 9 

VA.2 무료 옵션 문제 . . . . 9 

VA.3 유동성 손실과 국가 채널 토폴로지 . . . . . 9 

VB 미래의 일. . . . . . . . . . . . . . 9 

VB.1 기능성 계약 언어 (9) 

VB.2 멀티 파티 채널 . . . . 9 

I. 서론 
이 백서의 목적은 Åternity 블록 체인 아키텍처 및 가능한 응용 프로그램 - . 더 자세한 논문은 앞으로 공개 될 예정이며, 구체적으로는 합의와 지배 구조를위한 것이다. 그러나 우리의 아키텍처는 전체 론적이라는 점에 유의해야합니다. 모든 구성 요소는 모듈 방식으로 함께 묶이고 시너지 효과를냅니다. 이 문서의 나머지 부분은 네 부분으로 나뉩니다. 첫째, 우리는 기본 이론적 아이디어를 소개하고 토론 할 것입니다. 우리 아키텍처에 알립니다. 둘째, 우리는 1

Page 2
필수 응용 프로그램, 기타 가능한 사용 사례 및 개발자로서 플랫폼을 사용하는 방법에 대한 직관을 제공하십시오. 세 번째로, 우리는 현재의 proof-of-concept 구현을 제시 할 것이다. 얼랑 (Erlang)에 쓰여있다. 우리는 토론으로 결론을 내리고, 가능한 미래 방향과 다른 것에 대한 비교를 포함하여 기술. A. 이전 작업 블록 코인은 우선 Bitcoin의 새로운 방식을 보여주었습니다. 인터넷 건축가 가치 교환에 [ 1 ]. 이것은 가지고있다. 많은 유망한 진보가 뒤 따랐다. Turing-complete smart con- blockchain 구조로써 책자 [ 2 ]; 트루스 코인 blockchains [에 신탁을 만들기위한 도구를 만들어 3] 동안, GroupGnosis와 Augur는 그들을 더 많이 만드는 법을 보여주었습니다. 실력 있는 [4]; Casey Detrio는 시장을 만드는 방법을 보여주었습니다. blockchains에 [ 5]; Namecoin은 도메인 네임 서버의 분산 당량 [6 ] 사실 해시를 저장하는 블록 체인이 모든 디지털 데이터의 존재의 증거 [ 7] . 이러한 기술은 앞으로 다가올 대단한 약속입니다. 누구에게나 최고의 금융 및 법률 서비스를 제공합니다. 그러나 지금까지 그들은 함께 모이는 데 실패했습니다. 통일 된 전체가 실제로 약속을 성취합니다. 구체적으로는, 지금까지의 모든 솔루션은 다음의 관점 : 거버넌스, 확장 성, 스크립팅 안전 및 실제 데이터에 도착하는 저렴한 액세스 [CIT가 필요합니다.]. Åternity aims 이러한 모든 측면에서 최첨단 기술을 향상시킬 수 있습니다. II. Æ TERNITY BLOCKCHAIN 우리는 확장 성, 스크립팅 안전성 부족 현재 "스마트 콘택트 렌즈 (smart con- 트러스트 플랫폼 "은 세 가지 핵심 쟁점에 이릅니다. 첫째, 현재 현 상태를 유지하고있는 현명한 설계로 현명한 계약 체결 분석하기 어려운 플랫폼 용으로 작성 1 , 그리고 statefulness 순차적 트랜잭션 순서와 결합하면 복잡해집니다. 확장 [CIT 필요하다.]. 둘째, 분산 된, 신뢰할 수없는 믿을만한 방법은 실현을 복잡하게하거나 철저히 방지합니다. 많은 유망한 응용 프로그램의 [CIT가 필요합니다.]. 셋째, 플랫폼 순서대로 자신을 업데이트 할 수있는 능력이 제한되어 있습니다. 새로운 기술적 또는 경제적 지식에 적응하는 것. 우리 이 세 가지 문제가 각각 명확한 해결책이 있다고 생각하십시오. 탐험해야 할 경로. 첫째, 국가 채널 기술에 관한 최근의 연구는, 많은 유스 케이스에서 상태를 체인으로 유지하는 것이 필요한 [CIT 필요하다.]. 저장하는 것이 전적으로 가능합니다. 상태 채널에있는 모든 정보, 블록 체인 만 사용 정보 교환의 경제적 결과를 해결하기 위해, 분쟁의 경우에는 대체로. 이것은 블록 체인 아키텍처에 대한 대안 접근법 튜링 완벽한 스마트 컨트랙트가 주 채널에 존재하지만 체인에 있지 않습니다. 모든 트랜잭션이 확장되므로 확장 성이 향상됩니다. 상태 계약을 분석 한 어려움은 매우 명확하게 보여줌했다 "DAO"를 무너 뜨린 재 입장 버그에 의해 나타났다. 이 일이 일어났다. Ethereum의 제작자들에 의해 감사 된 코드에도 불구하고 물론 일반 사회로 [CIT가 필요합니다.]. 따라서 독립적으로 처리되어 병렬로 처리 될 수 있습니다. 또한 이것은 계약서가 공유에 쓰지 않는다는 것을 의미합니다. 테스트 및 검증이 크게 단순화되었습니다. 우리 이 디자인은 블록 체인 (blockchains)이 데이터 저장보다는 재정 논리에 관한 것; 존재 블록 체인을 보완하는 분산 스토리지 솔루션 아주. 둘째, Augur와 같은 응용 프로그램은 실제 데이터를 분산 형 블록 체인의 블록 체인에 가져옵니다. 본질적으로 합의를 이끌어내는 과정에서 [8 스마트 계약 내부기구 ] 대신 이용하는 기본 블록 체인의 합의 메커니즘 이 비효율적이지만 보안을 강화하지는 않습니다. 그만큼 자연적인 결론은 블록 체인을 일반화하는 것이다. 정보를 제공 할 수있는 일치 메커니즘 다음 내부 상태뿐 아니라 상태 외부 세계의 따라서, blockchain의 합의 메커니즘은 어떤 복잡한 이론이 오라클 머신을 더빙하는지 실행 : 튜링보다 더 강력한 이론적 기계 기계는 몇 가지 질문에 대한 해답을 가지고 있기 때문에 반드시 "누가 축구 경기에서 우승했는지 X는? "[CIT가 필요합니다.]. 셋째, 합의 메커니즘 또한 시스템의 매개 변수를 결정하는 데 사용될 수 있습니다. 이를 통해 변화하는 외부 조건에 적응할 수 있습니다. 새로운 연구와 최근의 개발을 채택하는 것 필드. 이 섹션의 나머지 부분에서는 Åternity 블록 체인을 소개합니다. 좀 더 자세하게 설명하면 계정에 대한 간략한 개요부터 시작하여 토큰, 이름 및 블록 구조. 이것 다음에 국가 채널과 스마트에 대한 우리의 접근 방식에 대한 설명 계약서를 작성한 다음 블록 체인이 합의 체계는 효율적인 방법을 만들기 위해 오라클 메커니즘을 사용하고 시스템을 제어합니다. 마지막으로, 우리는 여러 각도에서 확장성에 대해 논의합니다. A. 토큰, 계정 및 블록 계약 개발자의 "무국적"임에도 불구하고 관점, Åternity 블록 체인은 여러 트랙을 유지합니다. 사전 정의 된 상태 구성 요소. 우리는 다음과 같이 설명 할 것입니다. 잘 각 블록의 내용으로. 간단히하기 위해이 섹션 모든 노드가 전체 블록 체인을 추적한다고 가정합니다. 가능한 최적화 절에서 설명 II-E. A.1) 액세스 토큰, 이온 : 블록 체인을 사용하는 것이 아닙니다. 무료이지만 사용자가 aeon이라는 토큰을 소비해야합니다. 이온은 소비하는 모든 자원에 대한 지불로 사용됩니다. 플랫폼 및 금융 애플리케이션의 기반 플랫폼에서 구현됩니다. 기원 블록에있는 이온의 분포는 Ethereum에서 호스팅되는 현명한 계약에 의해 결정됩니다. 더욱이 이온은 채굴을 통해 창출 될 것입니다. 모든 시스템 비용은 aeon, 모든 현명한 계약으로 지불됩니다. 에 정착하다. A.2) 계정 : 각 계정에는 주소와 bal- 에이스의 에이스, 그리고 매 순간마다 증가하는 넌스 거래 및 마지막 업데이트의 높이. 각 계정 2

Page 3
그것이 시간의 금액에 대한 약간의 수수료를 지불해야합니다 열다. 계정을 만들고 유지하는 비용으로 인해 스팸을 차단하고 주 팽창을 저해합니다. 삭제에 대한 보상 계정은 공간 재 확보를 장려합니다. A.3) 이름 시스템 : 많은 블록 체인 시스템이 겪고있다. 사용자가 읽을 수없는 주소. 아론의 정맥에 Swartz의 작품과 Namecoin, Æthternity에는 이름이 있습니다 분산되고 안전한 시스템입니다. 지지 인간 친화적 이름 [9 ]. 블록 체인의 상태 인간에게 친숙한 고유 한 문자열에서 고정 사이즈의 바이트 배열 이 이름을 사용하여 Åternity상의 계정 주소 나 해시와 같은 것들 Merkle 나무의. A.4) 블록 내용 : 각 블록은 다음을 포함한다. 구성 요소 : • 이전 블록의 해시. • 거래의 해시 트리. • 계정의 해시 트리. • 이름의 해시 트리. • 개방 채널의 해시 트리. • 응답하지 않은 신탁의 해시 트리 그 각각의 질문. • 오라클 답변의 해시 트리. •는 Merkle 교정의 해시 트리. • 난수 생성기의 현재 엔트로피. 이전 블록의 해시는 블록 체인의 순서. 트랜잭션 트리에는 현재 블록에 포함 된 트랜잭션. 와 더불어 공감대 투표 나무를 제외한 모든 나무들은 완전히 합의하에 : 나무가 한 블록에서 다른 블록으로 바뀌면 다음으로이 변경 사항은 새 트랜잭션의 트랜잭션으로 인한 것입니다. 블록의 트랜잭션 트리 및 Merkle 업데이트 증명 블록의 증명 트리에 포함되어야합니다. 목적 나머지 3 개의 나무가 희망적으로 뒤에 오는 단면도. B. 상태 채널 가장 흥미로운 개발 중 하나 blockchain 공간은 최근 상태 채널의 공간입니다. 그들은 작동한다. 대부분의 경우 사람들 만이 거래의 영향을 받아야합니다. 본질적으로, 거래 당사자는 블록 체인에서 일부 상태를 인스턴스화합니다. 예를 들어 Ethereum 계약 또는 Bitcoin multisig. 그때 그들은 서명 된 업데이트를이 상태로 보내면됩니다. 중요한 점은 이들 중 어느 쪽이 이들을 사용할 수 있다는 것입니다. 블록 체인의 상태를 업데이트하지만, 대부분의 경우, 그들은하지 않습니다. 이를 통해 거래가 수행 될 수 있습니다. 정보를 전송하고 처리 할 수있는 최대한 빨리 당사자들이 대신에 기다릴 필요없이 거래가 확인되었고 잠재적으로 최종 승인되었습니다. 블록 체인의 합의 메커니즘에 의해 Åternity에서 해결할 수있는 유일한 상태 업데이트 blockchain은 aeon의 전송이고, 유일한 aeon은 거래 당사자가 양도 할 수 있습니다. 이미 채널에 기탁되어있다. 모든 채널을 만듭니다. 서로 독립적이며, 1 매크로 골드 f870e8f615b386aad5b953fe089; 2 삼 골드 오라클 4 0 1000 else 0 0 end 5 0 무화과. 1. 금 가격에 베팅을 인코딩하는 간단한 계약. 언어 사용되는 부분에 제시된다 앞뒤로 형상 Chalang 인 IV-A. 채널과 관련된 모든 트랜잭션을 처리 할 수 ​​있습니다. 동시에 트랜잭션 처리량을 크게 향상시킵니다. 블록 체인은 최종 결과를 해결하는 데에만 사용됩니다. 또는 발생하는 충돌을 해결할 수 있습니다. 사법 제도. 그러나, 블록 체인의 행동 예측 가능할 것입니다. 의도 한대로 논쟁 할 이익이 없습니다. 주 채널의 결과; 악의적 인 행위자는 장려된다. 올바르게 행동하고 최종 상태를 블록 체인. 모두 함께 취하면 거래가 늘어납니다. 속도와 부피를 수십 배나 증가 시켰습니다. 프라이버시로. B.1) 현명한 계약 : 체인에 정착 할 수있는 것은 이온의 이동이며, 왠지 Turing-complete 가상 머신을 여전히 제공합니다. "현명한 계약"을 실행하십시오. 뮌헨에 대한 계약은 엄격히 일부 규칙에 따라 자금을 분배하는 협약, 엔티티와 같은 계약과는 정반대의 입장에 서있다. 예 : Ethereum. 두드러진 실용적인 차이점 기본적으로 관련 당사자들만이 주어진 계약 및 열린 상태의 당사자 만 채널은 유효한 계약을 생성 할 수 있습니다. 당사자들이 계약서에 서명하고 나중에 서명 할 수 있도록 사본을 보관하십시오. 그 결과가 블록 체인에있는 경우에만 블록 체인에 제출됩니다. 이 경우 코드는 부분적으로 만 저장됩니다. 제출 된 거래의 이 경우 블록 체인은 다음과 같이 토큰을 배포합니다. 계약을 체결하고 채널을 닫습니다. 예를 들어, 그림. 도 1은 매우 간단한 계약을 보여준다 특정 시간에 금 가격에 베팅을 인코딩합니다. 라인 1에서, 매크로 Gold는 해당 오라클 식별자를 저장하고, 금 가격이 $ 38 / g 이하이면 true를 반환합니다. 2016 년 12 월 1 일. 계약의 본문이 표시됩니다. 2 ~ 4 행 : 금색 신탁의 식별자를 스택을 호출하고 oracle을 사용하여 호출하면 스택 맨 위에 오라클의 대답. 우리는 이것을 사용하여 조건부 분기 : 오라클이 true를 반환하면 우리는 0 및 1000을 스택에 추가하면 0을 지정해야합니다. 태워서 1000에 첫 번째 참가자에게 가야한다. 채널. 그렇지 않으면 0과 0을 푸시하고 두 번째 0과 함께 다른 참가자가 모든 채널. 마지막으로 nonce로 간주되는 0을 푸시합니다. 이 채널 상태. 실제 사용에서는 nonce가 배포시 생성됩니다. 주목해야 할 중요한 점 중 하나는 Åternity 자신의 상태를 유지하지 마십시오. 모든 상태가 유지됩니다. 거래 당사자가 제출하여 실행시 입력으로 제출합니다. 모든 계약은 본질적으로 삼

Page 4
1 : 해시 록 2 교환 삼 해시시 4 ==; 무화과. 2. 간단한 해시 락. 1 매크로 약속 a9d7e8023f80ac8928334; 2 삼 약식 해시 록 호출 4 if 0 100 else 0 50 end 5 1 무화과. 3. 해시 록을 사용하여 중개인을 통해 신뢰없이 토큰을 보냅니다. 입력으로서 새로운 채널 상태를 출력으로 제공 2 . 혜택 일반적으로 소프트웨어 개발에서 순수 함수를 사용하는 것, 특히 금융 애플리케이션 개발에있어, 학계와 산업계에서 광범위하게 문서화되어있다. 수십 년 동안 [ 10] [CIT가 필요합니다.]. a) 계약 상호 작용 및 다단계 계약 : 비록 모든 계약이 무국적이며, 계약의 상호 작용과 상태 유지 여전히 hashlocking 통해 달성 될 수 CIT 필요하다.]. 단순한 해시 락 (hashlock)은 그림 4에 나와있다. 2 . 1 행에서 함수를 정의합니다. 스택이 해시를 포함 할 것으로 기대하는 hashlock h와 비밀. 그것은 해쉬하기 위해 2 행에 그들을 바꾼다. 평등 연산자를 호출하기 전에 3 행의 비밀 해시 (v) 및 라인 4에 h. 비밀이 해시의 이미지. 이 함수는 술어에 사용할 수 있습니다. 코드의 실행은 같은 비밀 값의 존재. 간단한 예제 사용법으로서, 해시 락은 상태 채널을 공유하지 않는 사용자가 각 채널을 신뢰없이 보냅니다. 다른 aeon 사이에는 채널 경로가있는 한 그들. 예를 들어 Alice와 Bob이 채널을 가지고 있고 Bob과 Carol은 채널을 가지고 있고, Alice와 Carol은 채널을 가질 수 있습니다. Bob을 통해 거래. 그들은 두 개의 사본을 만들어 이것을한다. 그림의 계약의 3 각 채널에 대해 하나. 그만큼 1 행의 약속은 앨리스의 비밀 선택한다. 3 행에서 스택으로 푸시하고 해시 록 기능. if의 어느 지점을 얻는 지 hashlock의 반환 값에 따라 달라집니다. 일단 이 계약은 모든 당사자가 서명했으며, Alice는 그 비밀은 Bob과 Carol이 그것을 사용하여 자신의 영겁. 해싱은 또한 예를 들어 멀티 플레이어 게임에 사용될 수 있습니다. 그림과 같이 채널에서 게임 . 4. 모두가 만듭니다. 동일한 것을 게시하는 게임 관리자와의 채널 모든 채널에 계약. 게임 상태 32에 있다고 가정 해 봅시다. 2 계약은 신탁 답변을 읽을 수 있기 때문에 주목해야한다 일부 환경 매개 변수는 완전히 순수한 함수가 아닙니다. 그러나 오라클의 답변은 제공되면 변경되지 않으며 오라클의 계산적 풍부함에 기인한다고 주장 될 수있다. 기계가 아니라 불순물. 환경 매개 변수가있는 것으로 간주됩니다. "필연적 인 악"이며 이상적으로는 고수준 언어. 1 매크로 약속 a9d7e8023f80ac8928334; 2 삼 약식 해시 록 호출 4 State33 else State32 end 인 경우 5 요구 무화과. 4. 해시 록을 사용하여 멀티 플레이어를 재생하는 단순화 된 예 채널 게임. State32 함수에 의해 정의되고 우리는 무분별하게 싶다. 동시에 모든 채널을 상태 33으로 업데이트합니다. 게임 관리자가 비밀을 밝혀 내고, 모든 채널을 야기합니다. 동시에 업데이트 할 수 있습니다. b) 계량 실행 : 계약 실행 계량 Ethereum의 "가스"와 비슷한 방식으로, 그러나 함평은 두 가지 그것의 계량을위한 다른 자원들, 하나는 시간을위한 것이고 다른 하나는 공간. 이 두 가지 모두 파티에 의해 이온을 사용하기 위해 지불됩니다. 그것은 실행을 요청합니다. 이것은 아마도 바람직하지 않은 것으로 여겨 질 수 있습니다. 블록 체인의 필요성을 야기하는 다른 당사자 먼저 분쟁을 해결하십시오. 그러나, 채널의 모든 돈은 도박에 사용되지 않습니다. 계약 코드에서 효과적으로 무효화됩니다. 일방에서 타방으로 자금을 재배포하는 능력. 그것 사실 모든 기금 사용을 피하는 것이 일반적으로 좋은 습관이다. 잃어 버리는 것을 소멸시키기 때문에 거래 할 채널에서 채널을 닫을 때 협력 할 수있는 사람. B.2) 예 :이 모든 아이디어를 지구. 실제로 Alice와 Bob이 Åternity의 주정부 채널, 그들은 다음을 통과합니다. 순서: 1) 앨리스 (Alice)와 밥 (Bob)은 그들 중 많은 돈이 채널을 만들어 블록 체인에 게시하십시오. 2) 블록 체인이 채널을 열면 둘 다 새로운 채널 상태를 만들고, 그 사이에 서로 서명하고 서명하십시오. 채널 상태는 다음 중 하나 일 수 있습니다. 채널에서의 새로운 자금 분배 또는 새로운 분배를 결정하는 계약. 각각의 이러한 채널 상태는 증가하는 넌스를 가지며 양 당사자가 서명 했으므로 분쟁 발생시 최신 유효한 상태를 블록 체인에 제출할 수 있습니다. 그것을 시행합니다. 3) 두 가지 다른 방법으로 채널을 닫을 수 있습니다. a) Alice와 Bob이 완료했다고 결정하면 거래하고 그들의 최종 잔고에 동의하며, 그들은 둘 다 이것을 나타내는 거래에 서명하고 블럭 체인에 제출하면 채널에서 채널을 재분배하고 채널에 돈을 재분배하십시오. 따라서. b) 앨리스 (Alice)가 어떤 이유로 든 Bob은 마지막 상태를 제출할 수 있습니다. 그들 중 서명하고 채널 요청 이 상태를 사용하여 종료되었습니다. 카운트 다운이 시작됩니다. Alice가 Bob이 부정직하다고 믿는다면, 그녀는 다음과 같은 상태를 게시 할 기회가 있습니다. 4

Page 5
두 사람 모두 서명 한 높은 넌스 카운트 다운이 끝나기 전에. 그녀가 그렇게한다면, 채널이 즉시 닫힙니다. 그렇지 않으면 닫습니다. 카운트 다운이 끝났을 때. C. 일치 메커니즘 ioternity는 하이브리드 증명 작업 (Proof-of-Work) 및 스테이크 증언 (Proof-of-Stake)을 사용합니다. 일치 메커니즘. 블록 순서가 결정됩니다. Proof-of-Work를 통해. 특정 시스템 변수는, 온 - 체인 예측 시장 시스템을 통해 채굴 사용자가 참여하고 지식을 가져올 수 있습니다. 에 대한 우리가 현재 Tromp의 변종을 선호하는 PoW 알고리즘 뻐꾸기주기, 메모리 바인딩 된 하나이며, 또한 "간접적으로 유용한 증명 작업 (Proof-of-Work)" 전기가 흐르지 만 대신에 또 다른 제한 요소가 있습니다. 메모리 대기 시간 가용성 중 하나입니다. 이것은 또한 그것을 만든다. 스마트 폰으로 채굴 할 수 있습니다. Tromp는 그의 작업에 대해 다음과 같이 씁니다 : "[뻐꾸기주기]는 즉각적으로 검증 가능한 기억이다. 독점적 인 PoW 대기 시간은 계산이 아닙니다. 그런 의미에서 min- ing Cuckoo Cycle은 ASIC 마이닝의 한 형태입니다. DRAM 칩은 무작위로 응용 프로그램을 제공합니다. 읽기 및 쓰기 수십억 비트. 하룻밤 사이에 충전되는 전화조차도 광산을 사용할 수 있습니다. 효율면에서 몇 배의 손실없이, 수익성에 대한 생각이 아니라 놀고있는 것 추첨, 채광 하드웨어 경관 광대 한 확장을보고, 채택뿐만 아니라 분산." 미리보기 : 일치 메커니즘은 다소 비선형 적이다. Åternity에서 표준 역할. 새로운 것에 동의하는 것 외에도 blockchain에 대한 블록, 그것은 또한 두 답변에 동의합니다. 오라클 질문 및 시스템 매개 변수의 값. 특히 합의 메커니즘은 스스로 변화 할 수있다. 그러나, 이것은 전적으로 unprob- lematic. 예를 들어, 간단한 작업 증명 (proof-of-work) 메커니즘 광부에게 뇌물을 제공하는 것이 다소 싸다. 오라클을 부패시킨다. 따라서 Åternity는 소설을 사용하려고합니다. 하이브리드 Proof-of-Stake Proof-of-Work 알고리즘, 활용 둘 다의 이득. 이와는 별도로 PoW는 새로운 aeon 토큰을 발행하는 데 사용됩니다. Sidenote : 원래 100 % 의도 된 Aeternity 스테이크 차단 블록 체인. 우리는 더 이상 생각하지 않는다. 분산 된 100 % PoS 시스템이 가능합니다. C.1) Oracles : 대부분의 계약에서 중요한 기능인, 텍스트 또는 코드로 인코딩되었는지 여부를 나타냅니다. 환경의 가치, 예를 들어 다른 가격 특정 이벤트가 발생했는지의 여부. 똑똑한 이 능력이없는 계약 시스템은 본질적으로 폐쇄적이다. 틀림없이 아주 유용하지는 않습니다. 이것은 일반적으로 ac- 사실을 이미 알고 있으며 이미 시도한 여러 프로젝트가있다. 분산 된 블록 체인에 외부 데이터 가져 오기 방법 [ 8] . 그러나 제공된 사실이 사실인지 여부를 결정하기 위해 또는 아닙니다, 이것들은 본질적으로 새로운 일치 메커니즘 위에 공감대 메커니즘. 서로 위에 두 개의 합의 메커니즘 실행하기 둘 다 별도로 운영하는 것만 큼 비쌉니다. 또한, 보안을 강화하지는 않습니다. 여전히 공격 받아 "허위"값을 산출합니다. 그러므로, 우리는 두 가지 합의 메커니즘을 본질적으로 우리가 동의하는 메커니즘을 재사용하는 것. 시스템의 상태에 관해서도, 바깥 세상. 이것이 작동하는 방식은 다음과 같습니다. 모든 aeon-holder 예 / 아니오로 응답하여 커밋함으로써 오라클을 시작할 수 있습니다. 문제. 그렇게 할 때, 그들은 또한 질문이 답변 될 수있는 기간. 앞으로도 얼마든지 시작할 수 있습니다. 사용자가 aeon을 비례 적으로 예금하기 위해 신탁을 시작합니다. 시간 길이의 길이로 반환됩니다. 사용자는 받아 들여지는 대답을 진리로 제공하고 그렇지 않으면 그것은 태워진다. 블록 체인은 다음에 대한 고유 식별자를 생성합니다. 한 번 대답을 검색하는 데 사용할 수있는 오라클 유효한. 일단 질문에 대한 답이 나오면, 오라클을 시작한 사용자는 무료 응답을 제공 할 수 있습니다. 오라클 런처가 응답을 제공하거나 일정 시간이 경과 한 후 다른 사용자가 제출할 수 있습니다. 같은 양의 aeon을 입금함으로써 반대 주장. 만약 마지막까지 반론을 제기하지 않았습니다. 시간 프레임, 사용자가 제공 한 답변은 오라클은 진실로 받아 들여지고 보증금은 반환됩니다. 만약에 어떠한 반대 주장이 제출되면 합의 메커니즘 블록은 오라클에 대답하는 데 사용됩니다. 이것은 더 많은 것이다. 비싸지 만, 우리가 알고 있기 때문에 우리는 적어도 두 안전 예금, 우리는 그것을 사용할 수 있습니다. D. 거버넌스 블록 체인 기반 시스템의 거버넌스가 커졌습니다. 과거의 문제. 시스템 업그레이드가 필요할 때마다 이 작업을 수행하려면 하드 포크가 필요합니다. 하드 포크는 대개 큰 용량으로 이어집니다. 모든 가치 보유자 간의 토론 간단한 것조차도. 소스 코드에서 임의로 설정된 변수를 다음과 같이 수정합니다. 우리는 Bitcoin에서 블록 크기 논쟁으로 보았습니다. 사용자의 인센티브가있는 시스템에서 매우 열심히 의사 결정권자와 일치하지 않는 명확한 업그레이드 경로가 없습니다. 우리는 또한 더 복잡한 것을 보았습니다. 단일 스마트 계약 버그 수정과 같은 거버넌스 결정 시스템에 의한 신속한 개입이 필요한 "The DAO" 개발자. 이 시스템의 가장 큰 문제점은 쉽게 식별 가능한 프로토콜에 대한 의사 결정 프로세스 - 학년이나 변화가 잘 정의되어 있지 않고 투명성이 부족합니다. Åternity의 거버넌스 시스템은 컨센서스의 일부입니다. 그것은 사용 예측 시장은 효율적이고 투명하게 기능합니다. 가능한 한. 더욱이, 합의 메카니즘은 num- 시스템 기능을 결정하는 변수들 새로운 블록마다 약간 업데이트됩니다. 에서 거래를하거나 오라클에게 물어 보는 데 드는 비용 블록과 같은 기본 매개 변수 값의 수정 시각. 5

Page 6
변수에 대한 예측 시장을 가짐으로써 프로토콜을 정의하면 사용자는 효율적으로 학습 할 수 있습니다. 프로토콜을 개선하십시오. 예측 시장을 보유함으로써 잠재적 인 단단한 포크, 우리는 지역 사회를 도울 수 있습니다. 사용할 코드의 버전에 대한 합의. 각 사용자 최적화하려는 측정 항목을 선택하지만 간단한 기본 전략은 가치를 극대화하는 것입니다. 그것의 보유. E. 확장 성 E.1) 샤딩 (Sharding) 나무 : 지금까지 전송 된 확장 성이 높습니다. 실행할 수 있습니다. 블록 체인은 각 사용자가 그들이 신경 쓰고 무시하는 블록 체인 상태의 일부 다른 사람들의 데이터. 적어도 한 부의 사본이 필요합니다. 신규 사용자가 관심있는 하위 상태에 대해 확신 할 수 있도록 약하지만 우리는이 데이터를 임의적으로 노드는 각 노드의로드가 임의로 작아 지도록로드됩니다. Merkle 나무는 상태가 하위 상태임을 증명하는 데 사용됩니다. [11 ]. 특정 노드가있는 시나리오를 상상하기 쉽습니다. 나무를 추적하고 돈을받는 것을 전문으로한다. 삽입 및 찾아보기 E.2) 경량 클라이언트 : 경량 클라이언트는 전체를 다운로드하지 않습니다. 블록. 먼저 사용자는 자신의 클라이언트에게 히스토리에 해쉬를 준다. 그들이 선호하는 포크, 약한 기술이라고도하는 기술 주관 [12 ]. 그런 다음 클라이언트는 다운로드 만한다는 것을 알고 있습니다. 해당 해시 블록을 포함하는 포크. 클라이언트 전용 블록의 헤더를 다운로드합니다. 헤더가 많이 있습니다. 전체 블록보다 작음. 처리되는 트랜잭션은 거의 없습니다. 단순하게하기 위해 우리는 블록 헤더에 대해 언급하지 않았다. 섹션의 블록 구조를 논의 할 때 , II-A.4을 하지만 그들은 다음을 포함합니다 : • 이전 블록의 해시. • 국가의 모든 나무의 뿌리 해시. E.3) 상태 채널과 병렬 처리 : 상태 채널 엄청난 처리량과 그들 내부의 대부분의 트랜잭션 블록 체인에서 실행되거나 기록되지 않습니다. 또한 채널은 공유 상태에 쓰지 않습니다. 체인을 통해 실제로 기록되는 모든 거래 블록 체인에서 병렬로 처리 할 수 ​​있습니다. 을 고려하면 오늘날 판매되는 대부분의 소비자 하드웨어는 적어도 4 개의 프로 - 코어 중단 (cessing cores)을 사용하면 트랜잭션 처리량에는 약 4 배가 곱 해집니다. 게다가 결코 어떤 복잡한도 없을 것이라는 사실 동시 상호 작용은이 블록 체인을 공유한다는 것을 암시합니다. 아키텍처는 비교적 쉬워야합니다. 블록 체인 이후 샤딩은 여전히 ​​실험적이며, 의도적으로 사용하고 있습니다. 초기에 샤딩 기술을 추구하지 않기로 결정했다. 넋의 디자인. 그러나 미래에 이것이 변하면, 영공은 분열시키는 가장 쉬운 블록 중 하나이어야합니다. E.4) 주어진 메모리에서 초당 트랜잭션 재개 quirement : 프로토콜을 정의하는 변수는 모두 합의에 의해 끊임없이 갱신되고있다. 처음부터 기본값을 계산할 수 있습니다. 초당 트랜잭션. 1 이것은 초안이며 아마도 2 변화. 삼 4 우리는 다음 변수를 정의합니다. 다음 계산 : 5 6 B = 블록 \ _ 크기 (바이트) 7 F = 블록 \ _till \ _finality 8 R = 시간 \ _till \ _finality (초 단위) 9 T = 트랜잭션 크기 (바이트) 10 11 초당 트랜잭션 수 = B * F / (T * R) 12 13 B = 1000000 바이트 = 블록 당 1 메가 바이트 14 하루에 F = 24 * 60 * 2 블록 15 명 R / F = 블록 당 30 초 16 R = 24 * 하루 3600 초 17 세 T = 트랜잭션 당 1000 바이트 18 19 1000000 * 24 * 60 * 2 / 1000 / 24 * 3600 20 = 1000000 / 1000 / 30 21 = ca. 초당 32 회의 트랜잭션 (빠름 8 명 안에 모든 인간을 등록 할만큼 충분히 연령) 노드를 운영하려면 모든 노드의 복사본을 보관해야합니다. 블록은 최종성 이후로 100 개를 기록 할 수 있어야합니다. 공격이있을 경우를 대비하여 더 많은 정보를 얻으십시오. 견적 그 최종성은 2 일이고, 그때까지 5760 블록이있을 것입니다. 최종. 따라서 메모리 요구량은 5760 * 1 메가 바이트입니다. * 100 = 576000 메가 바이트 = 576 기가 바이트. 거기에있을 때 일어나는 공격이 아니며, 약 5.76 만 필요합니다. 블록을 저장하기위한 기가 바이트. III. PPLICATIONS 영리 스마트 계약의 무국적 성격은 Åternity 's에서 다음 응용 프로그램을 쉽게 작성할 수 있습니다. 블록 체인. 특히 대용량 사용에 적합합니다. 사례. A. 블록 체인 핵심 요소 Blockchain essentials는 aeon과 같은 필수 프리미티브입니다. 지갑, 이름 및 관련 개념. 그들은 모듈화한다. 응용 프로그램 foun- dations에 향상시킬 수 있습니다. A.1) ID : 각 계정에는 고유 ID 번호. 사용자는 고유 한 이름을 등록 할 수 있습니다. 링크 이름을 데이터 구조의 Merkle-root에 연결합니다. 그만큼 데이터 구조는 자신의 유일한 ID와 다른 ID를 포함 할 수 있습니다. 자기 계정에 관한 정보. 우리는 Schema.org의 개인 또는 회사와 같은 것을 나타내는 JSON 형식 [ 13] . A.2) 지갑 : 지갑은 사용되는 소프트웨어입니다 Aeternity와 상호 작용할 수 있습니다. 지갑이 개인 키를 관리합니다. 거래를 만들고 서명합니다. 하나는 사용할 수 있습니다. 지갑을 사용하여 채널 트랜잭션을 보내고 채널 네트워크. A.3) 존재 증명 : 하나의 거래 유형으로 모든 데이터의 해시 게시. 시스템 참여자 헤더가 데이터가 존재한다는 것을 증명할 수 있습니다. 시간. 6

Page 7
B. 상태 채널 응용 프로그램 주정부 채널의 스마트 계약은 마이크로 채널에 이상적입니다. 높은 트랜잭션을 필요로하는 웹상의 서비스 - 놓다. B.1) Toll API : 현재 존재하는 대부분의 API는 공개적으로 누구든지 전화를 걸거나 다른 사람이 전화를 걸면 username-password-scheme 또는 고유 한 액세스 토큰 지불- 멘토 채널은 새로운 종류의 API를 허용합니다. API를, 아마도 모든 HTTP 요청에 대한 모든 호출에 대해 지불한다. API를 액세스하기 위해 지불하는 것은 디 도스 문제를 해결하고, 만든다 그것은 쉽게 항상 사용할 수 있습니다 고품질의 API를 구축합니다. 지불을 요구하는 API 응답은에 대한 기본적인 의 창조 사업의 또 불가능 종류와 수의 등 분산의 출현에 중요한 역할을 경제. 그들은에게 정보 소유자에 대한 인센티브를 만들 그렇지 않으면 개인 데이터를 공개합니다. B.2) 보험 크라우드 펀딩 : 우리는 보험 구현할 수 있습니다 지배적 인 보증 계약을 사용하여 크라우드 펀딩 [CIT가 필요합니다.] .이들은 돈을 마련하는 데 사용되는 스마트 계약이다 공공의 이익, 새로운 다리, 학교 나 시장 같은. 지배적 인 보증 계약은 전통적인 된 직후 다를 Kickstarter를 같이 한 신뢰 계약이 점에서 그들이 만드는 그것 우월 전략은 참여. 좋은이 지원되지 않는 경우, 모든 참가자는 다시 플러스 관심 자신의 이온을 얻을, 그래서 그들은있다 을받지 않고 유동성을 감소에 대한 보험 좋은. 오라클을 사용하여, 우리는의 제공되도록 할 수 있습니다 좋은 또는 서비스 인 경우 재화 나 서비스에만 지급됩니다 실제로 제공. B.3) 간 원자 쇄 스왑 : 크로스 사슬 원자를 스왑 bitcoins 대한 신용이없는 이온의 교환 정보 [수 14] ,[15 ]. 이러한하는 hashlock를 사용하여 구현 잠금 장치가 될 수있다동일한 값 아래 모두에 blockchains 거래. B.4) 안정 값 자산과 포트폴리오 복제 : 우리 유지 합성 자산을 프로그래밍하는 스마트 계약을 사용할 수 있습니다 거의 실제 자산과 같은 가격. 예를 들어, 우리는 금과 같은 가격을 유지 자산을 만들 수 있습니다. 합성 유도체가 같고 방향이 반대 쌍으로 생성된다. 한 사용자의 경우, 다른를 금으로 이동 자산을 가지고 사용자는 금 역으로 이동 자산을해야합니다. 예를 들어, 앨리스는 밥과 계약을 체결 할 수 있도록 앨리스는 금 1g을 소유하고있다. 돈 중 계약에서, 이온의 골드 가치가 1 그램는 앨리스로 이동합니다 남은 돈은 밥에 간다. 계약은 만료가 있습니다 금의 가격이 측정됩니다 날짜 및 자금 이에 따라 앨리스와 밥에게 배포. B.5) 이벤트 계약 : 이벤트 계약이 이벤트 지불 발생 및 이벤트가 발생하지 않는 경우와 같이 지불하지 않습니다 오라클의 이야기 당. 그렇다 them- 흥미로운되는 자아는 이러한 여러 다른 응용 프로그램에서 사용할 수 있습니다 : A) 보험 : 우리는 imple-하는 이벤트 계약을 사용할 수 있습니다 , 표준 보험. 예를 들어, 고가의 음악 이벤트 티켓 날씨가 나쁜가는 경우 가치가 될 수 있습니다. 그러나, 오라클이 있다고 결정하면 콘서트가는 사람은 돈을 받는다 이 이벤트의 날에 비가에게, 투자가 될 수 있습니다 하나는 emotionally-을 찾아 줄 수 있도록 보호 적절한 대안. 약간 더 심각하게, 농부는 A의 비가 인치의 총 수에 종종 관심 시즌. 우리는에서 시들고 농작물에 대해 그들을을 보장 할 수 건고. b)는 고발 이벤트 계약도 사용할 수 있습니다 민감한 정보를 공개 장려합니다. 예를 들어, 우리는 것을 나타내는 이벤트 "정보에 내기 할 수 A 회사는에 출시 된 불법 농약을 사용했거나 월 24 일 이전에 2017 년 ". 그런에 접근 할 수있는 모든 사람 정보는 첫번째 내기 이벤트에 인센티브된다 발생 후를 발표 할 예정이다. B.6) 예측 시장 : 예측 시장으로 작동 사용자가 미래의 이벤트가 일어날 여부에 내기시키는. 에서 베팅의 가격은 우리가 미래의 가능성을 예측할 수있다 [ 3] ,[8 ], [16]. 그들은을 측정 할 수있는 가장 정확한 방법입니다주어진 가격에 미래는 [CIT가 필요합니다.] . 이벤트가 발생하면,시장은 오라클을 사용하여 해결한다. 섹션에서 언급 한 바와 같이 II-D , 우리는 예를 들면 predic- 사용기 시장이 될 소프트웨어에있는 업데이트 예측하는 유익하고 해로운하는 것입니다. 우리는 또한 사용할 수 있습니다 실제로 선거에서 얼마나 많은 후보를 것으로 추정합니다 거짓말과 근거없는 약속이 될 수 있도록, 달성 할 수 보다 용이하게 검출. 무화과. 5. 다차원 예측 시장. A) 다차원 예측 시장 : Multidimen- 적인 예측 시장은 우리가 상관 관계를 예측할 수 향후 이벤트 사이. 그래서 예를 들어, 하나는 수 예측 앨리스는 지도자, 감자의 가격 선출되는 경우 아래로 갈 것입니다, 그리고 밥이 승리하면 가격이 올라갈 것입니다. 하나는 배울 수있는 구글은 3 다음 계획 A를 사용하는 경우 아마 더 많은 돈을 벌, 그리고 것이라고 개월, 그것이 경우 플랜 B를 사용, 아마 덜 적립됩니다. 또는,도있다. 5 , 우리앨리스가 대통령에 당선 될 경우가 있음을 볼 수있다 감자의 가격의 높은 가능성은 다소 낮은 것. B.7) 단일 가격으로 일괄 거래와 시장 :가 강탈하려는 공격자에 대한 두 가지 접근 방법이있다 시장에서 이온. 그들은 시장을 이용할 수 있습니다 시간 분할되고, 또는 그들이되고 그것을 활용할 수 있습니다 공간 분할합니다. • 시장이 공간에 분할되는 경우, 공격자는 않습니다 중재. 그는 동시에 mar-에 거래를한다 그래서 KETS는 한 번에 자신의 위험을 상쇄하고 그는 번다 7

Page 8
이익. • 시장이 시간에 분할되는 경우, 공격자의 전면 시장을 실행합니다. 그는 거래에 들어오는 읽고 시장과 즉시 주문을 구매 및 판매 생성 이전과 이후. 무화과. 제 흑색 선 수요 곡선이며, 적색 라인 공급이다 곡선. 빨간색의 판매는 빨간색으로 구매와 같은 크기입니다. 수직 라인은 마켓 메이커가 선택한 가격입니다. (A)에서 구입하고자하는 모든 사람 그 가격에 거래 높은 가격은 기꺼이 모든 사람들이 저렴한 가격으로 판매하는 그 가격에 거래. 공간에 시장을 결합하려면, 모두가를 사용해야합니다 같은 마켓 메이커. 시간에 시장을 결합하기 위해, 우리는 필요 거래는 단일 가격에 일괄 적으로 수행해야합니다. 시장 메이커 그가 결정 어떤 가격 각 사람에게 위탁 할 필요가, 누군가가에서 모순 약속을 찾을 수 있다면 마켓 메이커는, 그의 모든 고객은 할 수 있어야 그의 모든 채널 드레인. 시장 메이커는에 저지른 경우 공정 가격, 그는 구매자의 동일한 볼륨을 일치하고 그림으로 함께 판매자 . 6 나타낸다. 그렇지 않으면, 그는 끝날 것도 비슷한 상황이다. 도 7은 , 이와 같이 많은 위험을 감수. 무화과. 7. 검은 색은 빨간색보다 훨씬 크다. 시장 메이커 판매 그것보다 더 많은 주식을 따라서 많은 위험에 복용 사고있다. IV. I MPLEMENTATION 대부분의 주요 개념은 이미 증명 개념이 imple- 얼랑에서 mentations. 이것은 blockchain 자체를 포함, 계약 언어와 VM, 오라클 및 관리 메커니즘뿐만 아니라 합의가 이전 버전 기구. 그것을 만들기 때문에 우리는 얼랑 / OTP를 사용했다 쉬운 많은 요청에 응답 할 수있는 코드를 작성하는 병렬와 충돌하지 않습니다. 가장 높은 업을 가진 서버 세계에서 시간은 얼랑 기반으로합니다. 그것은 사용되어왔다 자신을 증명하는 30 년 산업용 애플리케이션은 일하기 신뢰할 수 있고 안정적인 제품입니다. A. 가상 머신 및 계약 언어 가상 머신은 스택 기반하고 넷째 유사 비교에서 비록에 비트 코인 '스크립트 언어, 후자는, 오히려 풍부하다. VM는, 대신 기능을 지원합니다 gotos으로 분석하기 위해 비교적 단순한 의미하기. VM의 옵 코드의 목록은 우리 Github에서 찾을 수 있습니다 삼 . 또한, 더 높은 수준의 넷째와 같은 LAN-이 존재 에 대한 바이트 코드로 컴파일 Chalang라는 게이지, VM. 이 매크로 변수 이름을 지원하지만 유지 스택 기반 실행 모델 [17 ]. Chalang 코드의 예우리 Github에서에도 찾을 수 있습니다 4 . 웹 통합을 통해 B. 채용 웹은 가장 인기있는 응용 프로그램 플랫폼입니다. 우리 같은 JS- 같은 쉬운 사용 웹 개발 도구를 제공합니다 Æternity의 핵심 기능에 대한 라이브러리와 JSON-API를 blockchain. C. 오픈 소스 모듈 위해 쉽게 개인 blockchain의 CON- 재 사용되는 sortium 및 기타 사용 사례, 소프트웨어가 작성됩니다 이러한 일치 된 모듈로 MIT 라이센스 모듈 수, 특정 요구에 적용 할 수. D. 유용성 및 UX 디자인 마찰이 인간의 상호 작용의 큰 초점이 될 것입니다 우리의 개발 노력. 보다 구체적으로, 우리는 확인한다 신원을 제어하는 ​​사람, 키와 트랜잭션이 명확하게하다 설립했다. 또한, 웹 게이트웨이를 통해 쉽게 액세스를 제공하는 것입니다 미래 발전의 중심 초점이 될. 참여하는 사용자 부싯깃 등을 통해 예측 시장 (왼쪽 / 오른쪽으로 스 와이프) 쉽게 할 수 있습니다 모바일 인터페이스, 간단한 웹 지갑 iframe을 통해 웹 사이트에 통합하는 것은 새로운 것 표준. V. D ISCUSSION 우리는 건축가하는 방법에 대한 설명을 제공 한 근본적 값보다 효율적인 전송 시스템. 그만큼 기술 시스템은 수 사실 글로벌 오라클 기계 세계적인 규모에서 의사 결정 서비스를 제공 할 수. 특히, 모든 응용 프로그램 섹션에서 제안 III 캔Æternity의 상단에 쉽고 효율적으로 구축 될 수있다. 삼 https://github.com/aeternity/chalang/blob/ 마스터 / opcodes.md 4 https://github.com/aeternity/chalang/tree/ 마스터 / 예 8

Page 9
그러나, 우리의 접근 방식은 근본적인 한계를 모두 가지고 및 개선을위한 도로. 이 여기에 설명되어 있습니다. A. 제한 사항 및 장단점 우리는 장단점이 만들어 믿고 않지만 우리 아키텍처는 결과 성능을 합리적인 주어진다 Æternity가 포괄 해결책이 아니라, 다른 지역에서 증가 분산 응용 프로그램. 그것은 오히려으로 간주되어야한다 기존 기술에 대한 시너지 효과를 보완. 있다 하나는 알고 있어야 할 몇 가지주의 사항. A.1)에 체인 상태 : 많은 장점을 가지고에도 불구하고, 프로그램 상태 Æternity 부족하기에 부적당하게 사용자 정의 상태를 필요로하는 응용 프로그램은 CON- 미만이어야합니다 공감대. 그들은 보통 예를 들어,이의 DAO를 포함 잉태, 사용자 정의 이름 시스템과 subcurrencies 기초 자산의 가치에 연결되지 않습니다. A.2) 무료 옵션 문제 : 앨리스와 밥이있는 경우 채널과 앨리스가 계약을 체결, 그녀는 기본적으로 밥을 제공합니다 그녀가 그에게 보내는 무료 옵션 : 밥이 선택할 수 있습니다 서명 및 시간에 (즉, 활성화) 계약을 반환 미래. 종종이 의도가 무엇 없습니다. 이를 방지하려면 문제는, 채널 계약은 즉시 활성화되지 않습니다 전체 금액. 그들은 시간과 공간에서 구분된다. 양자 모두 참가자들은 작은 간격으로 계약에 가입 할 어느 사용자가 사상에 큰 무료 옵션을 제공합니다 너무 다른. 예를 들어, 당사자는, 100 이온을 내기하려는 경우 각각을 증가 시킨다는 그들은 1000 단계에서에 가입 할 수 0.1 이온에 의해 내기. 이것은 약 1000 메시지를 필요 이후 싼만큼 각 방향으로 500을 통과 계약은 blockchain에 제출되지 않습니다. 또 다른로 예를 들어 하나는 금융 자산을하기를 원한다면, 그 것 백일 동안 지속, 하나는 하나의 2400 단계에서 가입 할 수 시간마다. 이는 전달에 대한 2400 메시지를 요구, 각 방향으로 1,200. A.3) 유동성 손실 및 주 채널 토폴로지 : 때 시연으로 hashlocks을 사용하여 채널을 구성 섹션 II-B.1 , 어떤 중간 적어도 두 번 잠글 필요많은 이온은 그들을 통해 전송됩니다. 에 대한 예를 들어, Alice와 캐롤이 밥을 통해 거래 할 경우, 밥은 앨리스와 상호 작용할 때 캐롤 역할을하고, 부의장 것 의 경우도 마찬가지입니다. 이 밥 고가이기 때문에, 그 가능성이 가장 높은 것 보상으로 수수료를 적립하실 수 있습니다. 앨리스와 캐롤에 예상되는 경우 서로간에 많은 거래를 실시, 그들은이를 방지 할 수 있습니다 새로운 채널을 생성하고 trustlessly 활성을 움직여 hashlock를 사용하여 새 채널로 계약. 정지는 별도의 채널을 개방 영향을 지키는 이후 하나의 유동성은 부정적으로, 중간을가는 것으로 예상된다 특히 경우에 경우에, 많은 경우에 바람직합니다 당사자는 미래에 많은 거래를 기대하지 않습니다. 따라서, 특정 풍부한 사용자로부터 돈을 벌 채널 토폴로지 trustlessly 다른 사용자간에 거래되는 전송 등장 할 것으로 예상. 이 하나를 구성하지 않는다는 것을 주목해야한다 실패의 지점, 우리는 이러한 트랜잭션을 신뢰하지 않기 때문에 아무것도 송신기. 송신기 전에 오프라인 상태가되면 hashlock의 비밀은, 트랜잭션을 밝혀졌다 통과하지 않습니다. 그것은 이후, 유일한 오프라인 상태가되면 가능 "부정적"효과는 송신기가 할 수없는 것입니다 그 이온 항에. B. 미래의 작업 현재 개선하는 방법에는 여러 가지 방법이 있습니다 건축물. B.1) 기능 계약 언어 : 합리적인 미래 방향은 높은 수준의 언어를 실험하는 것 그 기능 패러다임에 더 밀접하게 준수합니다. 유지- 암시 스택의 트랙을 보내고 것은 일반적으로 오류가 발생하기 쉬운이며 높은 수준의 개발자 대향위한 LAN- 틀림 적합하지 게이지. 이것은 오히려 쉬운 프로그램이라는 것을 부여해야 이미 순수 기능 (일부 환경 변수를 모듈로) 크게 개발과 형식 모두를 단순화 것 계약의 검증. 이 작업이 완료되면, 그것은 또한 만들 수 VM을 개정 감각은 단단히 새와 결합한다 언어는 컴파일 에러가 덜 발생하기 쉬운 덜 만들려면 개발자에 대한 신뢰에 의존한다. 이상적으로, 번역 표면 언어와 VM에 코드는 단순히 직접 것 동료 검토 연구의 전사, 실용하지만 양보 가능성이 될해야합니다. B.2) 멀티 파티 채널 : 현재 모든 채널에서 Æternity은 두 당사자로 제한됩니다. 다자간 찬 동안 넬스가 사실상하는 것은 hashlocking 통해 달성 될 수 있고, 이것은 수 비싼. 따라서, 우리는 가능성을 조사 할 계획 의 m-의-N과 함께, N 자 채널에 대한 지원을 추가 결제 메커니즘. G LOSSARY ME-와 분산, 변조 방지 데이터베이스를 Blockchain 리하여 액세스 할 수 있습니다. 데이터베이스는의 성장 목록에 의해 정의된다 블록을 연결된 해시 및 추가에 대한 규칙을 가질 수 있습니다 그들. 이온 이온 계정 단위 및 액세스를 나타낸다 바로 Æternity의 blockchain합니다. 그것은 양도 할 수있다. 거래가 blockchain에 사용자의 메시지입니다. 이것은 사용자가 액세스 할 수 그들의 통화를 사용할 수있는 방법입니다 blockchain. 두 사용자 사이의 주 채널 A의 관계는 기록 blockchain합니다. 그것은 사용자가 다시 이온을 보낼 수 있습니다 앞뒤로 사이 신용이없는 스마트 계약을 만듭니다 그들이 적용되고 blockchain에 의해 해결되는. 해시 입력으로 임의의 크기의 이진 소요 해시. 그것은 준다. 고정 된 크기의 출력. 같은 입력은 항상에 해시 동일한 출력. 출력을 감안할 때, 하나는 계산할 수 없다 입력. 이것은 우리가 채널의 쌍을 연결하는 방법입니다 Hashlocking 2 개 이상의 사람을 포함하는 스마트 계약을합니다. 비밀은 그것의 해시에 의해 참조됩니다. 때 비밀은 계시, 같은 여러 채널을 업데이트 할 수 있습니다 시각. 대한 의사 결정의 거버넌스 잘 정의 된 프로세스 blockchain의 미래 프로토콜 (들). 9

Page 10
오라클 대한 blockchain 사실을 알려주는 메커니즘 우리가 살고있는 세계는. 오라클 사용자를 사용하면을 예측할 수있다 blockchain 시스템에 외부 이벤트의 결과. 가치 홀더 A는 이온을 소유하는 사용자 또는 금융 deriva- 시스템에적인. 검사기 A를 유효성 검사기는에 참여하는 사용자입니다 합의 메커니즘. Æternity, 모든의 경우 가치 홀더 참여할 수 있습니다. 감사의 말 블라드, 매트, 폴, 더크, 마틴, 알리스 테어, 데본 덕분에 증명 읽기와 벤. 이 덕분에 다른 많은 통찰력있는 토론 명. R EFERENCES 

[1] S. 나카 모토 "비트 코인 : 피어 투 피어 전자 화폐 시스템, "2008 년 [온라인]. 사용 가능 :은 https : / / bitcoin.org/bitcoin.pdf. 

[2] V 버티린 "에테 : 차세대 스마트 CON- 기관 및 분산 응용 프로그램 플랫폼, "2014. [온라인]. 사용 가능 :은 https : / / github에. COM / 에테 리움 / 위키 / 위키 / 화이트 종이. 

[3] P 스턱, "시장 경험주의,"[온라인]. 유효한: http://bitcoinhivemind.com/papers/1_ Purpose.pdf. 

[4] M. M. 리 스톤 및 Köppelmann의 "ORA-에 방문 CLE, "2016 년 [온라인]. 사용 가능 : https : //로 블로그. gnosis.pm. 

[5] C 데트리오, "스마트 계약 스마트 시장,"2015. [온라인]. 사용 가능 : http://cdetr.io/smart- 시장 /. 

[6] 네임 코인 위키, 2016 년 [온라인]. 사용 가능 : HTTPS : //wiki.namecoin.org/index.php?title= 환영. 

[7] P 스노우, B 데리, 루 J., 등, "Factom :. 비즈니스 온 불변의 감사 추적에 의해 보안 프로세스 blockchain, "2014 년 [온라인]. 가능 : HTTP : / / bravenewcoin.com/assets/Whitepapers/ Factom-Whitepaper.pdf. 

[8] J. J. 피터슨 크루그 "점술가 : 탈 중심화 예측 시장, '2014 오픈 소스 플랫폼입니다. [온라인]. 사용 가능 : HTTP : / / bravenewcoin. COM / 자산 / 백서 / 점술가 - A - 분산 - 오픈 - 소스 - 플랫폼 - 에 대한 예측-Markets.pdf. 

[9] A. 스와 츠 "삼각형 제곱 : 안전한 decentral- 화 된, 사람이 읽을 수있는 이름, "2011 년 [온라인]. 이익- 수 : HTTP : / / www가. aaronsw. COM / 블로그 / squarezooko. 

[10] T 빗브드, "공식 언어의 설문 조사에 대한 공식 언어 및 분석에 계약 " 계약 지향 소프트웨어, 2010, PP. 29-32. [에- 선]. 사용 가능 : HTTP : / / www가. diku. DK / hjemmesider / ansatte / hvitved / 간행물 / hvitved10flacosb.pdf. 

[11] RC는 Merkle, "공개 키 cryptosys-을위한 프로토콜 보안 및 개인 정보 보호에 관한 IEEE 심포지엄에서 TEMS ", 1980. 

[12] V 버티린, "지분의 증명 : 내가 배운 방법 약한 주관 사랑, "2014 년 [온라인]. 유효한: https://blog.ethereum.org/2014/11/ 25 / 증거 - 지분 - 학습 - 사랑 - 약 - 주관/. 

[13] "Schema.org 스키마,"2016 년 [온라인]. 유효한: http://schema.org/docs/schemas.html. 

[14] "원자 크로스 체인 거래,"2016 년 [온라인]. 이익- 수 : HTTPS : / / 엉. 비트 코인. IT / 위키 / 원자 % 5C_cross 체인 %의 5C_trading. 

[15] "Interledger,"2016 년 [온라인]. 사용 가능 : https : //로 interledger.org/. 

[16] KJ 화살표, R 포사이스, M 골햄, 등. "라고 예측 시장, "과학, (320) 2008 년 약속. [온라인]. 사용 가능 : http://mason.gmu.edu/ ~rhanson / PromisePredMkt.pdf. 

[17] Z. 헤스 "Chalang"2016 [온라인]. 유효한: https://github.com/aeternity/chalang.